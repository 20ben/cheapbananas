<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Interactive map application with location search, scrollable sidebar, and detailed location information panel" />
    <title>Map Locations - Search & Explore</title>

    <!-- Google Fonts - Roboto for consistent Material Design look -->
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            font-family: "Roboto", -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
            background: #f3f4f6;
        }

        /* Sidebar Styles - Enhanced with Google Maps aesthetic */
        .sidebar {
            width: 384px;
            background: white;
            box-shadow: 0 0 10px rgb(60 64 67 / 28%);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .search-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.12);
            background: white;
            position: sticky;
            top: 0;
            z-index: 2;
        }

        .search-input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: #f9fafb;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
            transition: all 0.2s ease;
        }

        .search-input-wrapper:focus-within {
            background: white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .search-icon {
            width: 20px;
            height: 20px;
            color: #5f6368;
        }

        .search-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            font-size: 0.875rem;
            color: #202124;
        }

        .search-input::placeholder {
            color: #5f6368;
        }

        /* Location List - Google Maps style */
        .location-list {
            flex: 1;
            overflow-y: auto;
        }

        .location-card {
            width: 100%;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
            text-align: left;
            border: none;
            background: white;
            border-left: 4px solid transparent;
            border-bottom: 1px solid rgba(0, 0, 0, 0.12);
        }

        .location-card:hover {
            background: #f8f9fa;
        }

        .location-card:active {
            background: #f1f3f4;
        }

        .location-card.selected {
            background: #e8f0fe;
            border-left-color: #1a73e8;
        }

        .location-card-content {
            display: flex;
            gap: 0.75rem;
        }

        .location-image {
            width: 64px;
            height: 64px;
            border-radius: 0.5rem;
            object-fit: cover;
            flex-shrink: 0;
        }

        .location-info {
            flex: 1;
            min-width: 0;
        }

        .location-name {
            font-weight: 500;
            font-size: 1em;
            color: #202124;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0.25rem;
            line-height: 1.4;
        }

        .location-badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            background: #f1f3f4;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: #5f6368;
            margin-top: 0.25rem;
            font-weight: 400;
        }

        .location-rating {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #5f6368;
        }

        .star-icon {
            width: 16px;
            height: 16px;
            fill: #fbbf24;
            color: #fbbf24;
        }

        /* Detail Panel - Google Maps aesthetic */
        .detail-panel {
            width: 384px;
            background: white;
            box-shadow: 0 0 10px rgb(60 64 67 / 28%);
            border-radius: 1rem 0 0 1rem;
            transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            position: absolute;
            right: 0;
            top: 0;
            height: 100vh;
            z-index: 20;
        }

        .detail-panel.hidden {
            transform: translateX(100%);
        }

        .detail-panel-content {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .detail-header {
            padding: 1.5rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.12);
            display: flex;
            justify-content: space-between;
            align-items: start;
            background: white;
        }

        .detail-title-section {
            flex: 1;
        }

        .detail-title {
            font-size: 1.4em;
            font-weight: 400;
            color: #202124;
            margin-bottom: 0.5rem;
            line-height: 1.3;
        }

        .detail-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border: 1px solid #dadce0;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            color: #5f6368;
            font-weight: 400;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 2rem;
            color: #5f6368;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            line-height: 1;
            border-radius: 0.25rem;
            transition: all 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .close-button:hover {
            background: #f1f3f4;
            color: #202124;
        }

        .close-button:active {
            background: #e8eaed;
        }

        .detail-image {
            width: 100%;
            height: 192px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .detail-body {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }

        .detail-item {
            display: flex;
            align-items: start;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem 0;
        }

        .detail-icon {
            width: 20px;
            height: 20px;
            color: #5f6368;
            margin-top: 0.125rem;
            flex-shrink: 0;
        }

        .detail-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #202124;
            margin-bottom: 0.125rem;
        }

        .detail-value {
            font-size: 0.875rem;
            color: #5f6368;
            line-height: 1.5;
        }

        .detail-rating-value {
            font-size: 1.125rem;
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .detail-rating-label {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .detail-footer {
            padding: 1.5rem;
            border-top: 1px solid rgba(0, 0, 0, 0.12);
            background: white;
        }

        .action-button {
            width: 100%;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: all 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
            margin-bottom: 0.5rem;
            font-family: "Roboto", sans-serif;
        }

        .action-button.primary {
            background: #1a73e8;
            color: white;
            border: none;
            box-shadow: 0 1px 2px 0 rgba(60, 64, 67, .3), 0 1px 3px 1px rgba(60, 64, 67, .15);
        }

        .action-button.primary:hover {
            background: #1765cc;
            box-shadow: 0 1px 3px 0 rgba(60, 64, 67, .3), 0 4px 8px 3px rgba(60, 64, 67, .15);
        }

        .action-button.primary:active {
            background: #1557b0;
            box-shadow: 0 1px 2px 0 rgba(60, 64, 67, .3), 0 1px 3px 1px rgba(60, 64, 67, .15);
        }

        .action-button.secondary {
            background: white;
            color: #1a73e8;
            border: 1px solid #dadce0;
        }

        .action-button.secondary:hover {
            background: #f8f9fa;
            border-color: #dadce0;
        }

        .action-button.secondary:active {
            background: #f1f3f4;
        }

        /* Map Styles */
        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .current-location-button {
            position: absolute;
            bottom: 1.5rem;
            right: 1.5rem;
            background: white;
            border: none;
            border-radius: 50%;
            padding: 0.75rem;
            box-shadow: 0 1px 2px 0 rgba(60, 64, 67, .3), 0 2px 6px 2px rgba(60, 64, 67, .15);
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.4, 0.0, 0.2, 1);
            z-index: 999;
        }

        .current-location-button:hover {
            background: #f8f9fa;
            box-shadow: 0 1px 3px 0 rgba(60, 64, 67, .3), 0 4px 8px 3px rgba(60, 64, 67, .15);
        }

        .current-location-button:active {
            background: #f1f3f4;
            box-shadow: 0 1px 2px 0 rgba(60, 64, 67, .3), 0 1px 3px 1px rgba(60, 64, 67, .15);
        }

        .current-location-icon {
            width: 24px;
            height: 24px;
            display: block;
            color: #5f6368;
        }

        /* Responsive adjustments */
        @media only screen and (max-width: 640px) {
            .sidebar {
                position: absolute;
                top: 50%;
                left: 0;
                right: 0;
                height: 50%;
                width: 100%;
            }

            .detail-panel {
                width: 100%;
            }

            .map-container {
                height: 50% !important;
            }
        }

        /* Smooth scrolling for all scrollable areas */
        .location-list, .detail-body {
            scrollbar-width: thin;
            scrollbar-color: #dadce0 transparent;
        }

        .location-list::-webkit-scrollbar, .detail-body::-webkit-scrollbar {
            width: 8px;
        }

        .location-list::-webkit-scrollbar-track, .detail-body::-webkit-scrollbar-track {
            background: transparent;
        }

        .location-list::-webkit-scrollbar-thumb, .detail-body::-webkit-scrollbar-thumb {
            background-color: #dadce0;
            border-radius: 4px;
        }

        .location-list::-webkit-scrollbar-thumb:hover, .detail-body::-webkit-scrollbar-thumb:hover {
            background-color: #bdc1c6;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Search Header -->
            <div class="search-header">
                <div class="search-input-wrapper">
                    <svg class="search-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                        <circle cx="12" cy="10" r="3"/>
                    </svg>
                    <input type="text" class="search-input" id="searchInput" placeholder="Search for places..." />
                </div>
            </div>

            <!-- Location List -->
            <div class="location-list" id="locationList"></div>
        </div>

        <!-- Detail Panel -->
        <div class="detail-panel hidden" id="detailPanel">
            <div class="detail-panel-content" id="detailPanelContent"></div>
        </div>

        <!-- Map Container -->
        <div class="map-container">
            <div id="map"></div>
            <button class="current-location-button" id="currentLocationBtn" title="Current Location">
                <svg class="current-location-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/>
                    <circle cx="12" cy="10" r="3"/>
                </svg>
            </button>
        </div>
    </div>

    <script>
        // ============================================================================
        // DATA
        // ============================================================================
        const locationData = [];

        // ============================================================================
        // GLOBAL STATE
        // ============================================================================
      function NeighborhoodDiscovery(configuration) {
        const widget = this;
        const widgetEl = document.querySelector('.neighborhood-discovery');

        widget.center = configuration.mapOptions.center;
        widget.places = configuration.pois || [];

        // Initialize core functionalities -------------------------------------

        initializeMap();
        initializePlaceDetails();
        initializeSidePanel();

        // Initialize additional capabilities ----------------------------------

        initializeSearchInput();

        // Initializer function definitions ------------------------------------

        /** Initializes the interactive map and adds place markers. */
        function initializeMap() {
          const mapOptions = configuration.mapOptions;
          widget.mapBounds = new google.maps.Circle(
            {center: widget.center, radius: configuration.mapRadius}).getBounds();
          mapOptions.restriction = {latLngBounds: widget.mapBounds};
          mapOptions.mapTypeControlOptions = {position: google.maps.ControlPosition.TOP_RIGHT};
          widget.map = new google.maps.Map(widgetEl.querySelector('.map'), mapOptions);

          // // Set initial zoom smaller
          // widget.map.fitBounds(widget.mapBounds, {
          //   padding: 0,
          //   maxZoom: 12
          // });

          widget.map.setCenter(widget.center);
          widget.map.setZoom(18);


          widget.map.addListener('click', (e) => {
            // Check if user clicks on a POI pin from the base map.
            if (e.placeId) {
              e.stop();
              widget.selectPlaceById(e.placeId);
            }
          });

          widget.map.addListener('zoom_changed', () => {
            // Customize map styling to show/hide default POI pins or text based on zoom level.
            const hideDefaultPoiPins = widget.map.getZoom() < ND_DEFAULT_POI_MIN_ZOOM;
            widget.map.setOptions({
              styles: [{
                featureType: 'poi',
                elementType: hideDefaultPoiPins ? 'labels' : 'labels.text',
                stylers: [{visibility: 'off'}],
              }],
            });
          });

          const markerPath = widgetEl.querySelector('.marker-pin path').getAttribute('d');
          const drawMarker = function(title, position, fillColor, strokeColor, labelText) {
            return new google.maps.Marker({
              title: title,
              position: position,
              map: widget.map,
              icon: {
                path: markerPath,
                fillColor: fillColor,
                fillOpacity: 1,
                strokeColor: strokeColor,
                anchor: new google.maps.Point(13, 35),
                labelOrigin: new google.maps.Point(13, 13),
              },
              label: {
                text: labelText,
                color: 'white',
                fontSize: '16px',
                fontFamily: 'Material Icons',
              },
            });
          };

          // Add marker at the center location (if specified).
          if (configuration.centerMarker && configuration.centerMarker.icon) {
            drawMarker('Home', widget.center,
                       '#1A73E8', '#185ABC', configuration.centerMarker.icon);
          }

          // Add marker for the specified Place object.
          widget.addPlaceMarker = function(place) {
            place.marker = drawMarker(place.name, place.coords, '#EA4335', '#C5221F', place.icon);
            place.marker.addListener('click', () => void widget.selectPlaceById(place.placeId));
            widget.updateBounds(widget.places);
          };
          

          // Fit map to bounds that contain all markers of the specified Place objects.
          widget.updateBounds = function(places) {
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(widget.center);
            for (let place of places) {
              bounds.extend(place.marker.getPosition());
            }
            widget.map.fitBounds(bounds, /* padding= */ 100);
          };

          // Marker used to highlight a place from Autocomplete search.
          widget.selectedPlaceMarker = new google.maps.Marker({title: 'Point of Interest'});
        }

        /** Initializes Place Details service for the widget. */
        function initializePlaceDetails() {
          const detailsService = new google.maps.places.PlacesService(widget.map);
          const placeIdsToDetails = new Map();  // Create object to hold Place results.

          for (let place of widget.places) {
            placeIdsToDetails.set(place.placeId, place);
            place.fetchedFields = new Set(['place_id']);
          }

          widget.fetchPlaceDetails = function(placeId, fields, callback) {
            if (!placeId || !fields) return;

            // Check for field existence in Place object.
            let place = placeIdsToDetails.get(placeId);
            if (!place) {
              place = {placeId: placeId, fetchedFields: new Set(['place_id'])};
              placeIdsToDetails.set(placeId, place);
            }
            const missingFields = fields.filter((field) => !place.fetchedFields.has(field));
            if (missingFields.length === 0) {
              callback(place);
              return;
            }

            const request = {placeId: placeId, fields: missingFields};
            let retryCount = 0;
            const processResult = function(result, status) {
              if (status !== google.maps.places.PlacesServiceStatus.OK) {
                // If query limit has been reached, wait before making another call;
                // Increase wait time of each successive retry with exponential backoff
                // and terminate after five failed attempts.
                if (status === google.maps.places.PlacesServiceStatus.OVER_QUERY_LIMIT &&
                    retryCount < 5) {
                  const delay = (Math.pow(2, retryCount) + Math.random()) * 500;
                  setTimeout(() => void detailsService.getDetails(request, processResult), delay);
                  retryCount++;
                }
                return;
              }

              // Basic details.
              if (result.name) place.name = result.name;
              if (result.geometry) place.coords = result.geometry.location;
              if (result.formatted_address) place.address = result.formatted_address;
              if (result.photos) {
                place.photos = result.photos.map((photo) => ({
                  urlSmall: photo.getUrl({maxWidth: 200, maxHeight: 200}),
                  urlLarge: photo.getUrl({maxWidth: 1200, maxHeight: 1200}),
                  attrs: photo.html_attributions,
                })).slice(0, ND_NUM_PLACE_PHOTOS_MAX);
              }
              if (result.types) {
                place.type = formatPlaceType(result.types[0]);
                place.icon = ND_MARKER_ICONS_BY_TYPE['_default'];
                for (let type of result.types) {
                  if (type in ND_MARKER_ICONS_BY_TYPE) {
                    place.type = formatPlaceType(type);
                    place.icon = ND_MARKER_ICONS_BY_TYPE[type];
                    break;
                  }
                }
              }
              if (result.url) place.url = result.url;

              // Contact details.
              if (result.website) {
                place.website = result.website;
                const url = new URL(place.website);
                place.websiteDomain = url.hostname;
              }
              if (result.formatted_phone_number) place.phoneNumber = result.formatted_phone_number;
              if (result.opening_hours) place.openingHours = parseDaysHours(result.opening_hours);

              // Review details.
              if (result.rating) {
                place.rating = result.rating;
                addStarIcons(place);
              }
              if (result.user_ratings_total) place.numReviews = result.user_ratings_total;
              if (result.price_level) {
                place.priceLevel = result.price_level;
                place.dollarSigns = initArray(result.price_level);
              }
              if (result.reviews) {
                place.reviews = result.reviews;
                for (let review of place.reviews) {
                  addStarIcons(review);
                }
              }

              for (let field of missingFields) {
                place.fetchedFields.add(field);
              }
              callback(place);
            };

            // Use result from Place Autocomplete if available.
            if (widget.placeIdsToAutocompleteResults) {
              const autoCompleteResult = widget.placeIdsToAutocompleteResults.get(placeId);
              if (autoCompleteResult) {
                processResult(autoCompleteResult, google.maps.places.PlacesServiceStatus.OK);
                return;
              }
            }
            detailsService.getDetails(request, processResult);
          };
        }

        /** Initializes the side panel that holds curated POI results. */
        function initializeSidePanel() {
          const placesPanelEl = widgetEl.querySelector('.places-panel');
          const detailsPanelEl = widgetEl.querySelector('.details-panel');
          const placeResultsEl = widgetEl.querySelector('.place-results-list');
          const showMoreButtonEl = widgetEl.querySelector('.show-more-button');
          const photoModalEl = widgetEl.querySelector('.photo-modal');
          const detailsTemplate = Handlebars.compile(
              document.getElementById('nd-place-details-tmpl').innerHTML);
          const resultsTemplate = Handlebars.compile(
              document.getElementById('nd-place-results-tmpl').innerHTML);

          // Show specified POI photo in a modal.
          const showPhotoModal = function(photo, placeName) {
            const prevFocusEl = document.activeElement;
            const imgEl = photoModalEl.querySelector('img');
            imgEl.src = photo.urlLarge;
            const backButtonEl = photoModalEl.querySelector('.back-button');
            backButtonEl.addEventListener('click', () => {
              hideElement(photoModalEl, prevFocusEl);
              imgEl.src = '';
            });
            photoModalEl.querySelector('.photo-place').innerHTML = placeName;
            photoModalEl.querySelector('.photo-attrs span').innerHTML = photo.attrs;
            const attributionEl = photoModalEl.querySelector('.photo-attrs a');
            if (attributionEl) attributionEl.setAttribute('target', '_blank');
            photoModalEl.addEventListener('click', (e) => {
              if (e.target === photoModalEl) {
                hideElement(photoModalEl, prevFocusEl);
                imgEl.src = '';
              }
            });
            showElement(photoModalEl, backButtonEl);
          };

          // Select a place by id and show details.
          let selectedPlaceId;
          widget.selectPlaceById = function(placeId, panToMarker) {
            if (selectedPlaceId === placeId) return;
            selectedPlaceId = placeId;
            const prevFocusEl = document.activeElement;

            const showDetailsPanel = function(place) {
              detailsPanelEl.innerHTML = detailsTemplate(place);
              const backButtonEl = detailsPanelEl.querySelector('.back-button');
              backButtonEl.addEventListener('click', () => {
                hideElement(detailsPanelEl, prevFocusEl);
                selectedPlaceId = undefined;
                widget.selectedPlaceMarker.setMap(null);
              });
              detailsPanelEl.querySelectorAll('.photo').forEach((photoEl, i) => {
                photoEl.addEventListener('click', () => {
                  showPhotoModal(place.photos[i], place.name);
                });
              });
              showElement(detailsPanelEl, backButtonEl);
              detailsPanelEl.scrollTop = 0;
            };

            const processResult = function(place) {
              if (place.marker) {
                widget.selectedPlaceMarker.setMap(null);
              } else {
                widget.selectedPlaceMarker.setPosition(place.coords);
                widget.selectedPlaceMarker.setMap(widget.map);
              }
              if (panToMarker) {
                widget.map.panTo(place.coords);
              }
              showDetailsPanel(place);
            };

            widget.fetchPlaceDetails(placeId, [
              'name', 'types', 'geometry.location', 'formatted_address', 'photo', 'url',
              'website', 'formatted_phone_number', 'opening_hours',
              'rating', 'user_ratings_total', 'price_level', 'review',
            ], processResult);
          };

          // Render the specified place objects and append them to the POI list.
          const renderPlaceResults = function(places, startIndex) {
            placeResultsEl.insertAdjacentHTML('beforeend', resultsTemplate({places: places}));
            placeResultsEl.querySelectorAll('.place-result').forEach((resultEl, i) => {
              const place = places[i - startIndex];
              if (!place) return;
              // Clicking anywhere on the item selects the place.
              // Additionally, create a button element to make this behavior
              // accessible under tab navigation.
              resultEl.addEventListener('click', () => {
                widget.selectPlaceById(place.placeId, /* panToMarker= */ true);
              });
              resultEl.querySelector('.name').addEventListener('click', (e) => {
                widget.selectPlaceById(place.placeId, /* panToMarker= */ true);
                e.stopPropagation();
              });
              resultEl.querySelector('.photo').addEventListener('click', (e) => {
                showPhotoModal(place.photos[0], place.name);
                e.stopPropagation();
              });
              widget.addPlaceMarker(place);
            });
          };

          // Index of next Place object to show in the POI list.
          let nextPlaceIndex = 0;

          // Fetch and show basic info for the next N places.
          const showNextPlaces = function(n) {
            const nextPlaces = widget.places.slice(nextPlaceIndex, nextPlaceIndex + n);
            if (nextPlaces.length < 1) {
              hideElement(showMoreButtonEl);
              return;
            }
            showMoreButtonEl.disabled = true;
            // Keep track of the number of Places calls that have not finished.
            let count = nextPlaces.length;
            for (let place of nextPlaces) {
              const processResult = function(place) {
                count--;
                if (count > 0) return;
                renderPlaceResults(nextPlaces, nextPlaceIndex);
                nextPlaceIndex += n;
                widget.updateBounds(widget.places.slice(0, nextPlaceIndex));
                const hasMorePlacesToShow = nextPlaceIndex < widget.places.length;
                if (hasMorePlacesToShow || hasHiddenContent(placesPanelEl)) {
                  showElement(showMoreButtonEl);
                  showMoreButtonEl.disabled = false;
                } else {
                  hideElement(showMoreButtonEl);
                }
              };
              widget.fetchPlaceDetails(place.placeId, [
                'name', 'types', 'geometry.location',
                'photo',
                'rating', 'user_ratings_total', 'price_level',
              ], processResult);
            }
          };
          showNextPlaces(ND_NUM_PLACES_INITIAL);

          showMoreButtonEl.addEventListener('click', () => {
            placesPanelEl.classList.remove('no-scroll');
            showMoreButtonEl.classList.remove('sticky');
            showNextPlaces(ND_NUM_PLACES_SHOW_MORE);
          });
        }


        let myLocations = []; // global

        /** Initializes Search Input for the widget. */
        function initializeSearchInput() {
          const searchInputEl = document.getElementById('searchInput');
          widget.placeIdsToAutocompleteResults = new Map();

          // Set up Autocomplete on the search input.
          const autocomplete = new google.maps.places.Autocomplete(searchInputEl, {
            types: ['establishment'],
            fields: [
              'place_id', 'name', 'types', 'geometry.location', 'formatted_address', 'photo', 'url',
              'website', 'formatted_phone_number', 'opening_hours',
              'rating', 'user_ratings_total', 'price_level', 'review',
            ],
            bounds: widget.mapBounds,
            strictBounds: true,
          });
          autocomplete.addListener('place_changed', async () => {
            
            const place = autocomplete.getPlace();
            const newLat = place.geometry.location.lat()
            const newLng = place.geometry.location.lng() 

            try {
              // Wait for the fetch to complete
              const response = await fetch("http://localhost:5000/submit_location", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ lat: newLat, lng: newLng })
              });
              
              const result = await response.json();
              myLocations = result

              // Now myLocations is populated, continue with the rest
              widget.map.panTo({lat: newLat, lng: newLng});
              widget.placeIdsToAutocompleteResults.set(place.place_id, place);
              widget.selectPlaceById(place.place_id, true);
              searchInputEl.value = '';

              const bounds = new google.maps.LatLngBounds();
              
              myLocations.forEach(loc => {
                const latLng = new google.maps.LatLng(loc[2].latitude, loc[2].longitude);
                bounds.extend(latLng);

                new google.maps.Marker({
                  position: latLng,
                  map: widget.map,
                  title: `Location: ${loc[2].latitude}, ${loc[2].longitude}`,
                  icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: 'red',
                    fillOpacity: 1,
                    strokeWeight: 1,
                    strokeColor: 'darkred'
                  }
                });
              });

              widget.map.fitBounds(bounds);
              
            } catch (error) {
              console.error('Error:', error);
            }
          });

        }

        

        // // Function to fetch data.
        // const fetchDataBtn = document.getElementById('fetchBtn')
        // fetchDataBtn.addEventListener('click', () => {
        //   const res = axios.get("http://127.0.0.1:5000/api/data")
        //       .then(res => console.log(res.data))
        //       .catch(err => console.error(err));
        // });

        // Recenter map on user location
        const locButton = document.getElementById('currentLocationBtn');
        locButton.addEventListener('click', () => {
          if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
              (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                // Recenter the map
                widget.map.panTo({ lat, lng });
                widget.map.setZoom(18); // optional, zoom closer to user

                fetch('http://127.0.0.1:5000/submit_location', {
                // sending lat and long to server.py 
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ lat: lat, lng: lng })
                })
                .then(response => response.json())
                .then(result => {
                  // do stuff
                  myLocations = result;

                })
                .catch(error => console.error('Error:', error));

              },
              (error) => {
                alert("Could not get location: " + error.message);
              }
            );
          } else {
            alert("Geolocation is not supported by this browser.");
          }
        });

      }
    </script>
    <script>
      let map;
      let markers = [];
      let autocomplete;

      // Render sidebar locations
      function renderLocationList(locations) {
        const list = document.getElementById("locationList");
        list.innerHTML = "";

        locations.forEach((loc, i) => {
          const card = document.createElement("button");
          card.className = "location-card";
          card.innerHTML = `
            <div class="location-card-content">
              <img class="location-image" src="${loc.imageUrl}" alt="${loc.name}">
              <div class="location-info">
                <div class="location-name">${loc.name}</div>
                <div class="location-badge">${loc.category}</div>
                <div class="location-rating">
                  ⭐ ${loc.rating} • ${loc.hours}
                </div>
              </div>
            </div>
          `;
          card.addEventListener("click", () => selectLocation(loc, i));
          list.appendChild(card);

          // Create marker
          const marker = new google.maps.Marker({
            position: getRandomNearby(),
            map: map,
            title: loc.name,
          });
          marker.addListener("click", () => selectLocation(loc, i));
          markers.push(marker);
        });
      }

      // Select location
      function selectLocation(loc, index) {
        const detailPanel = document.getElementById("detailPanel");
        const detailContent = document.getElementById("detailPanelContent");

        detailPanel.classList.remove("hidden");
        detailContent.innerHTML = `
          <div class="detail-header">
            <div class="detail-title-section">
              <div class="detail-title">${loc.name}</div>
              <div class="detail-badge">${loc.category}</div>
            </div>
            <button class="close-button" id="closeDetail">×</button>
          </div>
          <img class="detail-image" src="${loc.imageUrl}">
          <div class="detail-body">
            <div class="detail-item">
              <span class="detail-label">Address:</span>
              <span class="detail-value">${loc.address}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Hours:</span>
              <span class="detail-value">${loc.hours}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Rating:</span>
              <span class="detail-value">${loc.rating}</span>
            </div>
            ${loc.deals ? `
              <div class="detail-item">
                <span class="detail-label">Deals:</span>
                <span class="detail-value">${loc.deals}</span>
              </div>
            ` : ''}            
          </div>
          `

          // if (loc.deals) {
          //   const dealsDiv = document.createElement('div');
          //   dealsDiv.className = 'detail-item';
          //   dealsDiv.innerHTML = `
          //     <div class="detail-item"
          //       <span class="detail-label">Deals:</span>
          //       <span class="detail-value">${loc.deals}</span>
          //     </div>
          //   `;
          //   detailContent.appendChild(dealsDiv);
          // }
          };
        

        document.getElementById("closeDetail").onclick = () => {
          detailPanel.classList.add("hidden");
        };

      // Fake coordinates generator — replace with real geocoding if needed
      function getRandomNearby() {
        const base = { lat: 37.7749, lng: -122.4194 };
        return {
          lat: base.lat + (Math.random() - 0.5) * 0.05,
          lng: base.lng + (Math.random() - 0.5) * 0.05,
        };
      }
    </script>

    <!-- Load Google Maps API -->

    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAn4h2aJ5gzIUxOdaxun2I01Y_rpl4Vd3Q&callback=initMap&libraries=places"
      async
      defer
    ></script>
    
    
    <script>
    function initMap() {
        const center = { lat: 37.7749, lng: -122.4194 }; // default SF
        const map = new google.maps.Map(document.getElementById("map"), {
            zoom: 12,
            center: center
        });

        // Add this RIGHT AFTER you create the map variable
        // Initialize Places Autocomplete
        const input = document.getElementById('searchInput');
        autocomplete = new google.maps.places.Autocomplete(input, {
            fields: ['place_id', 'geometry', 'name', 'formatted_address', 'types']
        });

        // Listen for place selection
        autocomplete.addListener('place_changed', async () => {
            const place = autocomplete.getPlace();
            const newLat = place.geometry.location.lat()
            const newLng = place.geometry.location.lng() 

            const searchInputEl = document.getElementById("searchInput");
            // Disable the search bar while fetching
            searchInputEl.disabled = true;
            searchInputEl.style.opacity = "0.5";
            // searchInputEl.style.cursor = "not-allowed";
            searchInputEl.placeholder = "Fetching nearby locations...";
                        
            try {
              // Wait for the fetch to complete
              const response = await fetch('http://127.0.0.1:5000/submit_location', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ lat: newLat, lng: newLng })
              });
              
              const result = await response.json();
              myLocations = result

              if (!place.geometry || !place.geometry.location) {
                  console.log("No details available for input: '" + place.name + "'");
                  return;
              }

              // Pan to the selected place
              map.panTo(place.geometry.location);
              map.setZoom(15);

              // Add a marker for the selected place
              new google.maps.Marker({
                  position: place.geometry.location,
                  map: map,  // ✓ Already correct
                  title: place.name,
                  icon: {
                      path: google.maps.SymbolPath.CIRCLE,
                      scale: 10,
                      fillColor: "#4285F4",
                      fillOpacity: 1,
                      strokeWeight: 2,
                      strokeColor: "white",
                  }
              });

              // Clear the input after selection
              input.value = '';

              const bounds = new google.maps.LatLngBounds();
              
              // Clear existing location data and markers
              locationData.length = 0;
              markers.forEach(m => m.setMap(null));
              markers = [];

              myLocations.forEach(loc => {
                const latLng = new google.maps.LatLng(loc[2].latitude, loc[2].longitude);
                bounds.extend(latLng);

                // Create location object from your Python API data
                const locationObject = {
                  name: loc[0], // displayName from your API
                  category: loc[6],
                  address: loc[1], // formattedAddress from your API
                  hours: loc[4],
                  rating: loc[3],
                  imageUrl: loc[5],
                  deals: loc[7]
                };

                // Add to locationData array
                locationData.push(locationObject);

                // Create the red marker
                const marker = new google.maps.Marker({
                  position: latLng,
                  map: map,
                  title: loc[0],
                  icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: 'red',
                    fillOpacity: 1,
                    strokeWeight: 1,
                    strokeColor: 'darkred'
                  }
                });

                // Add click listener to marker
                marker.addListener("click", () => selectLocation(locationObject));
                
                markers.push(marker);
              });

              // Re-render the location list with new data
              renderLocationList(locationData);

              map.fitBounds(bounds);  // CHANGE THIS: was widget.map, now just map
              
            } catch (error) {
              console.error('Error:', error);
            } finally {
              // Re-enable search bar after fetching
              searchInputEl.disabled = false;
              searchInputEl.style.opacity = "1";
              searchInputEl.style.cursor = "text";
              searchInputEl.placeholder = "Search for places...";
            }
        });

        // Try to get user's location
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const userLocation = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };
                    map.setCenter(userLocation);
                    map.setZoom(15);

                    new google.maps.Marker({
                        position: userLocation,
                        map: map,
                        title: "You are here",
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 8,
                            fillColor: "#4285F4",
                            fillOpacity: 1,
                            strokeWeight: 2,
                            strokeColor: "white",
                        }
                    });
                },
                (err) => {
                    console.warn("User denied location or it could not be determined.", err);
                }
            );
        } else {
            console.warn("Geolocation not supported by this browser.");
        }

        // Render sample data points
        locationData.forEach((loc) => {
          const marker = new google.maps.Marker({
            position: getRandomNearby(),
            map: map,
            title: loc.name,
          });
          marker.addListener("click", () => selectLocation(loc));
        });


        // Current location button
        document.getElementById("currentLocationBtn").addEventListener("click", () => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const userLocation = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        map.setCenter(userLocation);
                        map.setZoom(15);
                    },
                    (err) => alert("Could not get location: " + err.message)
                );
            }
        });

        renderLocationList(locationData);

    }
    </script>
    


</body>
</html>